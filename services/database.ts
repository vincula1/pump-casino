
import { User } from '../types';
import { INITIAL_BALANCE } from '../constants';
import { createClient, SupabaseClient } from '@supabase/supabase-js';

/* 
  === SUPABASE SETUP INSTRUCTIONS ===
  If you are seeing 404 errors, your database table does not exist.
  Run this SQL in your Supabase SQL Editor:

  create table users (
    id bigint generated by default as identity primary key,
    wallet_address text not null unique,
    balance numeric default 1000,
    avatar_url text,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null
  );
*/

export interface DatabaseProvider {
  getUser(walletAddress: string): Promise<User>;
  updateUserBalance(walletAddress: string, newBalance: number): Promise<User>;
}

// --- LOCAL SIMULATION ADAPTER (Reliable Fallback) ---
class LocalAdapter implements DatabaseProvider {
  async getUser(walletAddress: string): Promise<User> {
    const key = `pump_casino_user_${walletAddress}`;
    let stored = null;
    try {
      stored = localStorage.getItem(key);
    } catch (e) { /* ignore */ }

    if (stored) {
      return JSON.parse(stored);
    }

    // Generate a new user if one doesn't exist locally
    const newUser: User = {
      username: walletAddress,
      balance: INITIAL_BALANCE,
      avatarUrl: `https://api.dicebear.com/9.x/bottts-neutral/svg?seed=${walletAddress}`
    };
    
    try {
        localStorage.setItem(key, JSON.stringify(newUser));
    } catch (e) {}
    
    return newUser;
  }

  async updateUserBalance(walletAddress: string, newBalance: number): Promise<User> {
    const key = `pump_casino_user_${walletAddress}`;
    const currentUser = await this.getUser(walletAddress);
    const user: User = {
      ...currentUser,
      balance: newBalance
    };
    try {
        localStorage.setItem(key, JSON.stringify(user));
    } catch (e) {}
    return user;
  }
}

// --- SUPABASE ADAPTER WITH CIRCUIT BREAKER ---
class SupabaseAdapter implements DatabaseProvider {
  private supabase: SupabaseClient;
  private localBackup: LocalAdapter;
  private isHealthy: boolean = true; // Circuit breaker flag

  constructor(url: string, key: string) {
    this.supabase = createClient(url, key, {
        auth: { persistSession: false }
    });
    this.localBackup = new LocalAdapter();
  }

  private switchToOfflineMode(reason: any) {
    if (!this.isHealthy) return; // Already offline, don't spam logs

    this.isHealthy = false;
    isLive = false;

    console.group("%cðŸ”Œ DATABASE DISCONNECTED - SWITCHING TO OFFLINE MODE", "background: #ef4444; color: white; padding: 4px; border-radius: 4px;");
    console.warn("Supabase connection failed. Using Local Storage fallback for this session.");
    
    // Check for 404 (Table not found)
    if (reason?.code === '42P01' || (reason?.message && reason?.message.includes('404'))) {
        console.log("%cREQUIRED ACTION: RUN THIS SQL IN SUPABASE DASHBOARD:", "color: #10b981; font-weight: bold; font-size: 12px;");
        console.log(`%ccreate table users (
  id bigint generated by default as identity primary key,
  wallet_address text not null unique,
  balance numeric default 1000,
  avatar_url text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);`, "color: #ccc; font-family: monospace;");
    } else {
        console.error("Connection Error:", reason);
    }
    console.groupEnd();
  }

  async getUser(walletAddress: string): Promise<User> {
    // 1. If circuit is broken, go straight to local to prevent network spam
    if (!this.isHealthy) {
        return this.localBackup.getUser(walletAddress);
    }

    try {
      // 2. Attempt real DB
      const { data, error } = await this.supabase
        .from('users')
        .select('*')
        .eq('wallet_address', walletAddress)
        .maybeSingle();

      if (error) throw error;

      if (data) {
        // Sync local backup for future safety
        this.localBackup.updateUserBalance(walletAddress, Number(data.balance));
        return { 
            username: data.wallet_address, 
            balance: Number(data.balance),
            avatarUrl: data.avatar_url || `https://api.dicebear.com/9.x/bottts-neutral/svg?seed=${walletAddress}`
        };
      }
      
      // 3. Create new user if not found
      const defaultAvatar = `https://api.dicebear.com/9.x/bottts-neutral/svg?seed=${walletAddress}`;
      const { data: newUser, error: createError } = await this.supabase
        .from('users')
        .insert([{ 
            wallet_address: walletAddress, 
            balance: INITIAL_BALANCE,
            avatar_url: defaultAvatar
        }])
        .select()
        .single();
        
      if (createError) throw createError;

      return { 
          username: newUser.wallet_address, 
          balance: Number(newUser.balance),
          avatarUrl: newUser.avatar_url
      };

    } catch (err: any) {
      // 4. Catch error, flip breaker, return local
      this.switchToOfflineMode(err);
      return this.localBackup.getUser(walletAddress);
    }
  }

  async updateUserBalance(walletAddress: string, newBalance: number): Promise<User> {
    // Always update local first (Optimistic UI)
    const localResult = await this.localBackup.updateUserBalance(walletAddress, newBalance);

    if (this.isHealthy) {
        this.supabase
          .from('users')
          .update({ balance: newBalance })
          .eq('wallet_address', walletAddress)
          .then(({ error }) => {
             if (error) {
                // If write fails, we don't necessarily break the circuit immediately unless it's a table missing error
                if (error.code === '42P01' || error.message?.includes('404')) {
                    this.switchToOfflineMode(error);
                }
             }
          });
    }

    return localResult;
  }
}

// --- INIT LOGIC ---
const FALLBACK_URL = "https://wkblzroluuljlsklxyeb.supabase.co";
const FALLBACK_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndrYmx6cm9sdXVsamxza2x4eWViIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM1ODYxMzgsImV4cCI6MjA3OTE2MjEzOH0.HpPtkq8gGZGH0-WDMyoFMuTEZwU64j397NJNLBmld1A";

const envUrl = process.env.VITE_SUPABASE_URL || process.env.NEXT_PUBLIC_SUPABASE_URL;
const envKey = process.env.VITE_SUPABASE_ANON_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

const finalUrl = (envUrl && envUrl.length > 10) ? envUrl : FALLBACK_URL;
const finalKey = (envKey && envKey.length > 10) ? envKey : FALLBACK_KEY;

export let db: DatabaseProvider;
export let isLive = false;

try {
    if (finalUrl && finalKey) {
        db = new SupabaseAdapter(finalUrl, finalKey);
        isLive = true; 
    } else {
        db = new LocalAdapter();
        isLive = false;
    }
} catch (e) {
    console.error("Critical Database Init Error", e);
    db = new LocalAdapter();
    isLive = false;
}
